-- Global number of paces moved
g_paces_movement = 100

-- Updates the global that manages the number of paces moved by the other functions, and updates the UI
function slider_paces_changed(player, value, id)
    g_paces_movement = round_to_power(value, 1)

    -- It's undocumented, but changing the value of the button does not update 
    -- the button_move_forward
    -- Instead we have to change the undocumented text attribute, but we still
    -- change the value because it's the proper thing
    UI.setAttribute('button_move_forward', 'text', 'Move ' .. g_paces_movement .. ' paces')
    UI.setValue('button_move_forward', 'Move ' .. g_paces_movement .. ' paces')

    -- Update any gizmo
    draw_gizmo_future_movements(player.getSelectedObjects())
end

function move_bases(player, value, id)
    local objs = filter_bases(player.getSelectedObjects())
    if tlen(objs) < 1 then
        print_error(player.steam_name ..' is trying to move 100 paces, but (s)he has no object selected, ignoring')
    return
    end

    for k,obj in ipairs(objs) do
        local moved_paces = move_base(obj, g_paces_movement)
        print_info(player.steam_name .. ' is moving ' .. obj.getName() .. ' ' .. moved_paces .. ' paces forward')
    end
    
    -- Moving the bases shpuld imply update the gizmos
    draw_gizmo_future_movements(player.getSelectedObjects())
end

function align_bases(player, value, id)
    local objs = filter_bases(player.getSelectedObjects())
    local n_objs = tlen(objs)
    if n_objs < 2 then
        print_error(player.steam_name ..' is trying to align ' .. n_objs .. ' bases, which is not supported')
        return
    end
    table.sort(objs, function(l, r)
        return l.getPosition()['x'] < r.getPosition()['x']
    end)

    -- Moving will mean that some attributes like the corner change, but they
    -- won't update on the object until next frame. However we still have to
    -- take into account here to aligning all the pieces together
    local future_transform = {}
    future_transform[objs[1].getName()] = get_transform(
        objs[1].getPosition(),
        compute_corners_base(objs[1]),
        objs[1].getRotation()
    )
    
    for i=2,n_objs do
        local pos = objs[i].getPosition()
        local corners = compute_corners_base(objs[i])
        local transform = get_closest_transform(corners["topleft"], future_transform)

        local distance_centers = distance_points_flat_sq(transform['position'], pos)
        if (distance_centers > g_max_distance_alignment) then
            print_error(player.steam_name .. ' is trying to align but the bases are too far apart, more than 3inch between centers!')
            return
        end

        future_transform[objs[i].getName()] = align_two_bases(
            objs[i], 
            transform['position'], 
            transform['corners'], 
            transform['rotation'])
    end
    
    -- Moving the bases shpuld imply update the gizmos
    draw_gizmo_future_movements(player.getSelectedObjects())
end

function debug_button(player, value, id)
    local objs = player.getSelectedObjects()
    for _, obj in ipairs(objs) do
    
        local corners_before = compute_corners_base(obj)
        print_debug('CORNERS PRE ' .. obj.getName() .. corners_to_str(corners_in_to_mm(corners_before)))

        obj.setRotation({0, 90, 0})
    
        local corners_after = compute_corners_base(obj)
        print_debug('CORNERS POST ' .. obj.getName() .. corners_to_str(corners_in_to_mm(corners_after)))
    end
end


function on_cancel_load_army(player, value, id)
    UI.setAttribute('panel_dba_troop_selection', 'active', false)
    UI.setAttribute('panel_dba_troop_selection_bg', 'active', false)
end

function on_load_army(player, value, id)
    local book_name = friendlyname_to_dataname(g_book_selected)
    local army_name = friendlyname_to_dataname(g_army_selected)

    spawn_army(armies[book_name][army_name], g_color_spawn_army_selected == 'Red')
    UI.setAttribute('panel_dba_troop_selection', 'active', false)
    UI.setAttribute('panel_dba_troop_selection_bg', 'active', false)
end

function create_army_options_menu()
    local status = UI.getAttribute('panel_dba_troop_selection', 'active')
    if status == 'True' then
        -- Ignore, the user is clicking despite the menu already being there
        return
    end

    g_book_selected = first_key_table(armies)
    local bookname = friendlyname_to_dataname(g_book_selected)
    local book = armies[bookname]
    g_army_selected = first_key_table(book)
    local army = armies[bookname][friendlyname_to_dataname(g_army_selected)]

    update_book_menu(1)
    on_next_frame(function()
        update_armies_menu(book, 1)
        on_next_frame(function()
            update_authors_text(army)
            on_next_frame(function()
                update_player_color_menu(g_color_spawn_army_selected == 'Red')
                on_next_frame(function()
                    UI.setAttribute('panel_dba_troop_selection_bg', 'active', true)
                    UI.setAttribute('panel_dba_troop_selection', 'active', true)
                end)
            end)
        end)
    end)
end

g_book_selected = ''
function on_book_selected(player, value, id)
    g_book_selected = value
    local new_book_name = friendlyname_to_dataname(value)
    local i = 1
    local selected_book_index = 1
    for book_name, book_armies in pairs(armies) do
        if book_name == new_book_name then
            selected_book_index = i
        end
        i = i + 1
    end

    g_army_selected = first_key_table(armies[new_book_name])
    local army = armies[new_book_name][friendlyname_to_dataname(g_army_selected)]

    on_next_frame(function()
        update_book_menu(selected_book_index)
        on_next_frame(function()
            update_armies_menu(armies[new_book_name], 1)
            on_next_frame(function()
                update_player_color_menu(g_color_spawn_army_selected == 'Red')
                on_next_frame(function()
                    update_authors_text(army)
                end)
            end)
        end)
    end)
end

g_army_selected = ''
function on_army_selected(player, value, id)
    g_army_selected = value
    local book_name_friendly = g_book_selected
    local book_name = friendlyname_to_dataname(book_name_friendly)
    local army_name = friendlyname_to_dataname(value)
    local army = armies[book_name][army_name]

    update_authors_text(army)
end

g_color_spawn_army_selected = 'Red'
function on_color_selected(player, value, id)
    g_color_spawn_army_selected = value
end

function add_pip(player, value, id)
    if value == 'red' then
        local pips_red = tonumber(UI.getValue('text_pips_player_red'))
        if pips_red < 6 then
            pips_red = pips_red + 1
        end
        UI.setValue('text_pips_player_red', pips_red)
    else
        local pips_blue = tonumber(UI.getValue('text_pips_player_blue'))
        if pips_blue < 6 then
            pips_blue = pips_blue + 1
        end
        UI.setValue('text_pips_player_blue', pips_blue)
    end
end

function remove_pip(player, value, id)
    if value == 'red' then
        local pips_red = tonumber(UI.getValue('text_pips_player_red'))
        if pips_red > 0 then
            pips_red = pips_red - 1
        end
        UI.setValue('text_pips_player_red', pips_red)
    else
        local pips_blue = tonumber(UI.getValue('text_pips_player_blue'))
        if pips_blue > 0 then
            pips_blue = pips_blue - 1
        end
        UI.setValue('text_pips_player_blue', pips_blue)
    end
end