
g_base_index = 1
g_bases = {}

function add_context_menu_base(base_obj)
    base_obj.addContextMenuItem("Move forward single", function()
        local moved_paces = move_base(base_obj, g_paces_movement)
        print_info(base_obj.getName() .. ' ' .. moved_paces .. ' paces forward')
    end)
    base_obj.addContextMenuItem("Move back single", function()
        local moved_paces = move_base(base_obj, -g_paces_movement)
        print_info(base_obj.getName() .. ' ' .. moved_paces .. ' paces backwards')
    end)
    base_obj.addContextMenuItem("Push forward single", function()
        push_forward(base_obj)
        print_info(base_obj.getName() .. ' pushed forward its own depth')
    end)
    base_obj.addContextMenuItem("Push back single", function()
        push_back(base_obj)
        print_info(base_obj.getName() .. ' pushed back its own depth')
    end)
    base_obj.addContextMenuItem("Turn around", function()
        local rotation = base_obj.getRotation()
        rotation['y'] = rotation['y'] + 180
        base_obj.setRotation(rotation)
        print_info(base_obj.getName() .. ' has rotated 180ยบ')
    end)
end

function add_context_menu_table(table_obj)
    table_obj.addContextMenuItem('Rotate 90ยบ', function()
        rotate_table()
    end)
    table_obj.addContextMenuItem('Fix terrain and lock', function()
        fix_terrain_and_lock()
    end)
    table_obj.addContextMenuItem('Toggle rulers', function()
        toggle_deployment_ruler()
    end)
end

function toggle_deployment_ruler()
    g_deployment_lines_enabled = not g_deployment_lines_enabled
    if g_deployment_lines_enabled then
        draw_deployment_lines()
    else
        remove_deployment_lines()
    end
end

function on_clone(source_obj, new_obj)
    local name = source_obj.getName()
    print_info(name .. " has been duplicated.")
    local new_name = name .. " clone " .. new_obj.getGUID()
    new_obj.setName(new_name)
    g_bases[new_name] = {
        tile = g_bases[name]['tile'],
        is_red_player = g_bases[name]['is_red_player']
    }
    new_obj.clearContextMenu()
    add_context_menu_base(new_obj)

end

function onObjectSpawn(new_obj)
    local name = new_obj.getName()
    local my_guid = new_obj.getGUID()
    if name ~= nil and str_starts_with(name, "base") then
        -- Check if the name as an old one
        local all_objs = getAllObjects()
        local bases = filter_bases(all_objs)
        local found_base = nil
        for _,base in ipairs(bases) do
            if base.getName() == name and base.getGUID() ~= my_guid then
                found_base = base
                break
            end
        end

        if found_base ~= nil then
            on_clone(found_base, new_obj)
        end    
    end
end

function spawn_base(base, pos, y_rotation, is_red_player)
    print_debug('Spawning base #' .. g_base_index)
    local overriden_tex = nil
    if base['ignore_terrain'] == nil then
        local type = from_toggle_number_to_table_type(g_current_table_type)

        if tables[type] == nil then
            type = 'grass'
        end

        if is_red_player then
            overriden_tex = tables[type]['red_player_base_tex']
        else
            overriden_tex = tables[type]['blue_player_base_tex']
        end
    end

    if base['name'] == nil then
        print_error('One of the bases of this army has no name! Please report to us so we can fix it asap')
        return
    end
    local base_obj = spawn_model(base['base'], pos, 0, nil, is_red_player, overriden_tex)

    local base_name = 'base ' .. base['name'] .. ' #' .. g_base_index
    base_obj.setName(base_name)
    add_context_menu_base(base_obj)

    g_base_index = g_base_index + 1
    g_bases[base_name] = {
        tile = base['base'],
        is_red_player = is_red_player
    }

    local n = base['n_models']
    if n == 0 then
        base_obj.setRotation({0, y_rotation, 0})
        base_obj.auto_raise = false
        return
    end

    local depth = get_depth_base(base['base'])
    local half_depth = depth / 2
    local half_width = g_base_width_inches / 2

    local rows = 1
    local columns = n
    if n > 4 then
        rows = math.floor(math.sqrt(n))
        columns = math.ceil(n/rows)

    end
    local column_width = g_base_width_inches / (columns + 1)
    local row_depth = depth / (rows + 1)

    for i=1,n do
        local column = (i - 1) % columns + 1
        local row = math.floor((i - 1) / columns) + 1

        local random_rotation = math.random(-20, 20)
        local random_rotation = math.random(0, 40) - 20
        if str_has_substr(base_name, 'Camp') then
            random_rotation = 0
        end

        local random_x = 0
        local random_z = 0
        if base['loose'] == true then
            random_x = random_float(-g_max_loose_spawn, g_max_loose_spawn)
            random_z = random_float(-g_max_loose_spawn, g_max_loose_spawn)
        end

        local relative_pos = {
            x = pos['x'] + column * column_width - half_width + random_x,
            y = pos['y'] + g_base_height_inches / 2,
            z = pos['z'] + row * row_depth - half_depth + random_x
        }
        local model_name = base['model_data']
        if model_name == nil then
            model_name = base['fixed_models'][i]
        end
        local soldier_obj = spawn_model(model_name, relative_pos, random_rotation, minimal_collider, is_red_player, nil)
        base_obj.addAttachment(soldier_obj)
    end

    base_obj.setRotation({0, y_rotation, 0})
    base_obj.auto_raise = false
end

-- Given an army object data, spawns it on the center of the table.
-- Hope nothing is in there and that all data is correct because this doesn't
-- validate
function spawn_army(army_name, army, is_red_player)
    math.randomseed(os.time())
    local n_bases = tlen(army) - 1
    local rows = 1
    if n_bases > g_max_bases_row then
        n_bases = g_max_bases_row
        rows = math.ceil(n_bases / g_max_bases_row)
    end

    local width_army = n_bases * g_base_width_inches

    local z_pos = g_spawn_from_center_in
    local y_rotation = 180
    if is_red_player then
        z_pos = g_spawn_from_center_in * -1
        y_rotation = 0
    end

    local i = 0
    for base_id, base_data in pairs(army) do
        if base_id ~= 'data' then
            local z_pos_modifier = -1 * get_depth_base(base_data['base']) / 2
            if is_red_player then
                z_pos_modifier = -1 * z_pos_modifier
            end

            local column = i % g_max_bases_row
            local row = math.floor(i / g_max_bases_row)

            local row_z_pos = z_pos * (1 + row)

            local location = {
                x = g_offset_deployment_x + column * g_base_width_inches - width_army / 2,
                y = g_base_height_tabletop + g_table_thickness + g_base_height_inches / 2,
                z = row_z_pos - z_pos_modifier
            }
            spawn_base(base_data, location, y_rotation, is_red_player)
            i = i + 1
        end
    end

    print_important('Army deployed: ' .. army_name .. ', see chat for options')
    print_info('List: ' .. army['data']['list'])
    print_info('Agressiveness: ' .. army['data']['aggresiveness']
        .. ' Terrain: ' .. army['data']['terrain'])

end

function get_author_tile(tilename)
    local tile = _G[tilename]
    return tile['author']
end

function get_author_model(modelname)
    local model = _G[modelname]
    return model['author']
end

function get_author_base(base)
    if base['n_models'] == 0 then
        return get_author_tile(base['base'])
    end
    local model = base['model_data']
    if model == nil then
        model = base['fixed_models'][1]
    end
    return get_author_model(model)
end

function update_authors_text(army)
    local authorship_models = 'The authors of the models are:\n\n'
    local authors_set = {}
    for base_id, base in pairs(army) do
        if base_id ~= 'data' then
            local author = get_author_base(base)

            if authors_set[author] == nil then
                authorship_models = authorship_models .. ' - ' .. author .. '\n\n'
                authors_set[author] = 1
            end
        end
    end
    UI.setValue('text_authors', authorship_models)
end

function update_book_menu(book_selected)
    local options = {}
    for book_name, book_armies in pairs(armies) do
        table.insert(options, dataname_to_friendlyname(book_name))
    end
    set_options_dropdown_by_id('dropdown_book', options, book_selected)
end

function update_player_color_menu(is_player_red)
    local selected = 2
    if is_player_red then
        selected = 1
    end
    set_options_dropdown_by_id('dropdown_color', { 'Red', 'Blue' },  selected)
end

function update_armies_menu(book, army_selected)
    local options = {}
    for army_name,_ in pairs(book) do
        table.insert(options, dataname_to_friendlyname(army_name))
    end
    set_options_dropdown_by_id('dropdown_army', options, army_selected)
end

g_current_table = nil
function spawn_table_obj(model_url, height_correction, texture_array_urls)
    local obj = spawnObject({
        type = 'Custom_Model',
        position = { x = 0, y = g_base_height_tabletop, z = 0},
        rotation = { x = 0, y = 0, z = 0},
        scale = { x = 1, y = 1, z = 1},
        sound = false,
        snap_to_grid = false,
        callback_function = function(obj)
            g_current_table = obj.getGUID()
            print_info('Table is set to ' .. g_current_table)
        end
    })
    local tex_index = math.random(1, #texture_array_urls)
    obj.setCustomObject({
        mesh = model_url,
        diffuse = texture_array_urls[tex_index],
        material = 1,
        cast_shadows = false,
        specular_sharpness = 0,
        specular_intensity = 0,
        freshnel_strength = 0
    })
    print_important('Table spawned, you can now put terrain on top, then use Right Click > Fix terrain.')

    add_context_menu_table(obj)
end

function rotate_table()
    local gametable = getObjectFromGUID(g_current_table)
    local newrotation = gametable.getRotation()
    newrotation['y'] = newrotation['y'] + 90
    gametable.setRotation(newrotation)
end

function fix_terrain_and_lock()
    local all_objs = getAllObjects()
    local terrains = {}
    for _,obj in ipairs(all_objs) do
        local name = obj.getName()
        if str_starts_with(name, 'terrain') then
            table.insert(terrains, obj)
        end
    end

    local gametable = getObjectFromGUID(g_current_table)
    local max_distance_from_table_sq = (g_width_table_in/2)^2 + (g_depth_table_in / 2)^2
    local pos_table = gametable.getPosition()

    local terrain_type = from_toggle_number_to_table_type(g_current_table_type)

    gametable.setLock(false)
    for _,terrain in ipairs(terrains) do
        local terrain_pos = terrain.getPosition()
        local distance = distance_points_flat_sq(pos_table, terrain_pos)
        if distance <= max_distance_from_table_sq
            and pos_table['y'] < terrain_pos['y'] then

            print_debug('Found terrain with name ' .. terrain.getName())

            if g_use_3d_terrain then
                process_vegetation(terrain, terrain_type)
            end
            
            gametable.addAttachment(terrain)
            print_info('Attaching ' .. terrain.getName())
        end
    end
    Wait.frames(function()
        g_current_table = gametable.getGUID()
        gametable.setRotation({ x = 0, y = 0, z = 0})
        gametable.setPosition({ x = 0, y = g_base_height_tabletop, z = 0})
        gametable.setLock(true)
        print_important('Table is now locked')
    end, 1)
end

function spawn_model(troop_name, pos, added_y_axis_rotation, collider, is_player_red, overridden_tex)
    -- Better pray that the input name actually exists! lol
    local model_data = _G[troop_name]

    local texture = overridden_tex
    if texture == nil then
        texture = model_data['player_blue_tex']
        if is_player_red then
            texture = model_data['player_red_tex']
        end
        -- Vegetation etc does not have that kind of player texture
        -- they are global
        if texture == nil then
            texture = model_data['texture']
        end
    end

    local meshes = model_data['mesh']
    local mesh_index = math.random(1, #model_data['mesh'])
    local selected_mesh = meshes[mesh_index]
    local spawn_data = get_spawn_model(pos,
        model_data['rotation'],
        model_data['height_correction'],
        model_data['scale'],
        selected_mesh,
        texture,
        collider)
    spawn_data['spawn']['rotation']['y'] = spawn_data['spawn']['rotation']['y'] + added_y_axis_rotation
    local obj = spawnObject(spawn_data['spawn'])
    obj.setCustomObject(spawn_data['custom_obj_attrs'])

    return obj
end

function get_spawn_model(pos, rotation_correction, height_correction, model_scale, model_mesh, model_diffuse, collider_if_exists)
    return {
        spawn = {
            type = 'Custom_Model',
            position = { x = pos['x'], y = pos['y'] + height_correction, z = pos['z']},
            rotation = { x = 0, y = rotation_correction, z = 0},
            scale = { x = model_scale, y = model_scale, z = model_scale},
            sound = false,
            snap_to_grid = false
        },
        custom_obj_attrs = {
            mesh = model_mesh,
            diffuse = model_diffuse,
            material = 3,
            collider = collider_if_exists
        }
    }
end

function onObjectDestroy(dying_object)
    local name = dying_object.getName()
    if is_table(dying_object) then
        print_info('Table removed from play')
        g_current_table = nil
    elseif g_bases[name] ~= nil then
        print_info('Base ' .. name .. ' removed from play')
        g_bases[name] = nil
    end
end


function spawn_proxy_bases()
    spawn_base({
        name = 'Proxy 40x15',
        base = 'tile_plain_4Bd_40x15',
        ignore_terrain = 'true',
        n_models = 0
    }, {x=-42, y=2, z=-11}, 0, true)
    spawn_base({
        name = 'Proxy 40x20',
        base = 'tile_plain_3Ax_40x20',
        ignore_terrain = 'true',
        n_models = 0
    }, {x=-42, y=2, z=-12}, 0, true)
    spawn_base({
        name = 'Proxy 40x30',
        base = 'tile_plain_3Cv_40x30',
        ignore_terrain = 'true',
        n_models = 0
    }, {x=-42, y=2, z=-13.5}, 0, true)
    spawn_base({
        name = 'Proxy 40x40',
        base = 'tile_plain_El_40x40',
        ignore_terrain = 'true',
        n_models = 0
    }, {x=-42, y=2, z=-15.5}, 0, true)


    spawn_base({
        name = 'Proxy 40x15',
        base = 'tile_plain_4Bd_40x15',
        ignore_terrain = 'true',
        n_models = 0
    }, {x=-42, y=2, z=11}, 180, false)
    spawn_base({
        name = 'Proxy 40x20',
        base = 'tile_plain_3Ax_40x20',
        ignore_terrain = 'true',
        n_models = 0
    }, {x=-42, y=2, z=12}, 180, false)
    spawn_base({
        name = 'Proxy 40x30',
        base = 'tile_plain_3Cv_40x30',
        ignore_terrain = 'true',
        n_models = 0
    }, {x=-42, y=2, z=13.5}, 180, false)
    spawn_base({
        name = 'Proxy 40x40',
        base = 'tile_plain_El_40x40',
        ignore_terrain = 'true',
        n_models = 0
    }, {x=-42, y=2, z=15.5}, 180, false)
end

function change_texture_terrain(terrain_obj, new_tex_url)
    print('New url is ' .. new_tex_url)
    local custom = terrain_obj.getCustomObject()
    custom['diffuse'] = new_tex_url
    terrain_obj.setCustomObject(custom)
end

function set_forest(terrain_obj, terrain_pos, terrain_rotation, terrain_size, table_type)
    local options = g_terrain[table_type]['forest']
    local ntrees = math.floor((terrain_size['x'] + terrain_size['z'])*1.3)
    for i=1,ntrees do
        local point = random_point_ellipse(terrain_size['x'] / 2.5, terrain_size['z'] / 2.5)
        new_pos = rotate_point_relative(point, terrain_pos, terrain_rotation)
        local obj = spawn_model(random_element(options['objects']), new_pos, math.random(1, 359), minimal_collider, true)
        terrain_obj.addAttachment(obj)
    end
    change_texture_terrain(terrain_obj, random_element(options['texture']))
end

function set_arid(terrain_obj, terrain_pos, terrain_rotation, terrain_size, table_type)
    local options = g_terrain[table_type]['rough']
    local nobjs = math.floor((terrain_size['x'] + terrain_size['z'])*2)
    for i=1,nobjs do
        local point = random_point_ellipse(terrain_size['x'] / 2.5, terrain_size['z'] / 2.5)
        new_pos = rotate_point_relative(point, terrain_pos, terrain_rotation)
        local obj = spawn_model(random_element(options['objects']), new_pos, math.random(1, 359), minimal_collider, true)
        terrain_obj.addAttachment(obj)
    end
    change_texture_terrain(terrain_obj, random_element(options['texture']))
end

function set_oasis(terrain_obj, terrain_pos, terrain_rotation, terrain_size, table_type)
    local options = g_terrain[table_type]['oasis']
    local nobjs = math.floor((terrain_size['x'] + terrain_size['z'])*1.2)
    for i=1,nobjs do
        local point = random_point_ellipse(terrain_size['x'] / 4, terrain_size['z'] / 4,
            math.min(terrain_size['x'] / 4, terrain_size['z'] / 4) - 0.3)
        
        new_pos = rotate_point_relative(point, terrain_pos, terrain_rotation)
        local obj = spawn_model(random_element(options['objects']), new_pos, math.random(1, 359), minimal_collider, true)
        terrain_obj.addAttachment(obj)
    end
    change_texture_terrain(terrain_obj, random_element(options['texture']))
end

function process_vegetation(terrain_obj, type)
    local terrain_pos = terrain_obj.getPosition()
    local terrain_rotation = normalize_angle(math.rad(terrain_obj.getRotation()['y']))
    local terrain_size = terrain_obj.getBoundsNormalized()['size']
    if str_starts_with(terrain_obj.getName(), 'terrain Forest') then
        set_forest(terrain_obj, terrain_pos, terrain_rotation, terrain_size, type)
    end
    if str_starts_with(terrain_obj.getName(), 'terrain Arid') then
        set_arid(terrain_obj, terrain_pos, terrain_rotation, terrain_size, type)
    end
    if str_starts_with(terrain_obj.getName(), 'terrain Oasis') then
        set_oasis(terrain_obj, terrain_pos, terrain_rotation, terrain_size, type)
    end
end