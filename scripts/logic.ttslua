-- Given a base object, computes the 4 bounds points, returned in a table,
-- each with a vector xyz of world pos coords
--
--   topleft         rotation      topright
--      +-------------^--------------+
--      |             |              |
--      |             * center       |  z axis
--      |                            |
--      +----------------------------+
--    botleft      x axis          botright
function compute_corners_base(base_obj)
    local rotation =  normalize_angle(from_degrees_to_rad(base_obj.getRotation())['y'])
    -- print_debug(base_obj.getName() .. ' rotation is ' .. rotation)
    local size = get_size(base_obj.getName())
    local pos = base_obj.getPosition()
    -- print_debug(base_obj.getName() .. ' pos is ' .. vec_to_str(vec_in_to_mm(pos)))
    return compute_corners_coords(size, rotation, pos)
end

-- Like compute_corners_base but instead of a base obj all coords are given
function compute_corners_coords(sizeXZ, rotationY, pos)
    local xhalf = sizeXZ['x'] / 2
    local zhalf = sizeXZ['z'] / 2

    return {
        topright = rotate_point_relative({x = xhalf, y = 0, z = zhalf}, pos, rotationY),
        botright = rotate_point_relative({x = xhalf, y = 0, z =-zhalf}, pos, rotationY),
        topleft  = rotate_point_relative({x =-xhalf, y = 0, z = zhalf}, pos, rotationY),
        botleft  = rotate_point_relative({x =-xhalf, y = 0, z =-zhalf}, pos, rotationY)
    }
end

-- Aligns base2 to a base1, where base1 is an object that will be (but may not
-- be there until next frame) with center position, corners and rotation.
-- Base2 is to the right of Base1 in the x axis
-- Returns a transform table with the new pos, corners and rot
function align_two_bases(base2, position, corners, rotation)
    base2.setRotation(rotation)
    local corners2 = compute_corners_base(base2)

    local angle = normalize_angle(math.rad(rotation['y']))
    local relative_angle = relative_angle_from_point(position, base2.getPosition(), angle)

    local translation = nil
    -- Note that since we know that base1 is to the left of base2, the angle
    -- is 0-90 or 270-360
    if relative_angle > g_alignment_angle_side
       and relative_angle < math.pi then
        -- Angle the back of base2 with the front of base1
        translation = vec_sub(corners['topright'], corners2['botright'])
    elseif relative_angle <= g_alignment_angle_side
           or relative_angle >= (2*math.pi - g_alignment_angle_side) then
        -- Angle the left side of base2 with the right of base1
        translation = vec_sub(corners['topright'], corners2['topleft'])
    else
        -- Angle the front of base2 with the back of base1
        translation = vec_sub(corners['botleft'], corners2['topleft'])
    end

    local new_pos = vec_add(base2.getPosition(), translation)
    base2.setPosition(new_pos)

    return {
        position = new_pos,
        corners = compute_corners_coords(get_size(base2.getName()),angle, new_pos),
        rotation = rotation
    }
end

-- Given a list of objects in a table, returns another table with ONLY
-- those who start with 'base', ignoring the keys
function filter_bases(list)
    local filtered = {}
    for _,obj in ipairs(list) do
        if str_starts_with(obj.getName(), 'base') then
            table.insert(filtered, obj)
        end
    end
    return filtered
end

-- Moves one or more DBA bases g_paces_movements paces forward
-- ASSUMES all bases are in a flat board!!!!
-- Returns how much it moved (it cna move less in a collision)
function move_base(obj, how_many_paces)
    local current_world_pos = obj.getPosition()
    local current_rotation = from_degrees_to_rad(obj.getRotation())
    local displacement_vector = rad_to_vector(current_rotation['y'])
    local magnitude = how_many_paces / 100
    local destination = vec_add(current_world_pos, vec_mul_escalar(displacement_vector, magnitude))
    -- print_debug(player.steam_name .. 'Moving ' .. obj.getName() ..
    -- ' from ' .. vec_to_str(current_world_pos) ..
    -- ' with rotation ' .. vec_to_str(current_rotation) ..
    -- ' to ' .. vec_to_str(destination))
    obj.setPosition(destination)
    -- TODO: COLISION

    return how_many_paces
end

function get_depth_base(tile_name)
    local base_data = _G[tile_name]
    return from_mm_to_in(base_data['depth'])
end

function get_size(base_name)
    return {
        x = g_base_width_inches,
        y = g_base_height_inches,
        z = get_depth_base(g_bases[base_name]['tile'])
    }
end

function is_base_red_player(base_name)
    return g_bases[base_name]['is_red_player']
end

function is_base_blue_player(base_name)
    return not is_base_red_player(base_name)
end

function max_distance_between_bases(base1_corners, base2_corners)
    return compute_max_array({
        distance_points_flat(base1_corners['topright'], base2_corners['topright']),
        distance_points_flat(base1_corners['topleft'], base2_corners['topleft']),
        distance_points_flat(base1_corners['botright'], base2_corners['botright']),
        distance_points_flat(base1_corners['botleft'], base2_corners['botleft'])
    })
end

g_picked_base_obj = nil
g_picked_base_initial_transform = nil
function onObjectPickUp(player_color,  picked_up_object)
    if g_bases[picked_up_object.getName()] == nil then
        return
    end

    local objs = filter_bases(Player[player_color].getSelectedObjects())
    local n_objs = tlen(objs)
    if n_objs > 1 then
        -- Ignoring this, we don't want to print the circle for more than one unit
        return
    end

    g_picked_base_obj = picked_up_object
    g_picked_base_initial_transform = calculate_transform(picked_up_object)
    local pos = g_picked_base_initial_transform['position']
    local radius = g_paces_movement / 100

    local color = g_gizmo_color_player_red
    if is_base_blue_player(picked_up_object.getName()) then
        color = g_gizmo_color_player_blue
    end

    Global.setVectorLines( {
        {
            points    = get_coordinates_circle(pos, radius, g_precision_circle),
            color     = color,
            thickness = g_line_thickness,
            rotation  = {0,0,0}
        }
    })
end

function onObjectDrop(player_color,  picked_up_object)
    if g_bases[picked_up_object.getName()] == nil then
        return
    end

    local objs = filter_bases(Player[player_color].getSelectedObjects())
    local n_objs = tlen(objs)
    if n_objs > 1 then
        draw_gizmo_future_movements(objs)
        return
    end

    local new_corners = compute_corners_base(picked_up_object)
    local distance = max_distance_between_bases(new_corners, g_picked_base_initial_transform['corners'])
    if distance < g_max_inches_snap then
        -- Snap back!
        distance = 0
        picked_up_object.setPosition(g_picked_base_initial_transform['position'])
        picked_up_object.setRotation(transform_to_rotation_vector(g_picked_base_initial_transform))
    end

    print_info(string.format('Movement for %q is %.1f paces', picked_up_object.getName(), distance * 100))

    g_picked_base_obj = nil
    g_picked_base_initial_transform = nil
    Global.setVectorLines({})

    -- If its dropped it may have moved, therefore update the gizmo, in case
    -- its selected
    draw_gizmo_future_movements(objs)
end

function calculate_future_position(base_obj, movement)
    local rotation = from_degrees_to_rad(base_obj.getRotation())['y']
    local displacement_vector = rad_to_vector(rotation)
    local destination = vec_add(base_obj.getPosition(), vec_mul_escalar(displacement_vector, movement))
    local size = get_size(base_obj.getName())
    local normalized_rotation = normalize_angle(rotation)
    local corners = compute_corners_coords(size, normalized_rotation, destination)

    return get_transform(
        destination,
        corners,
        normalized_rotation
    )
end

function calculate_transform(base_obj)
    return {
        position = base_obj.getPosition(),
        corners = compute_corners_base(base_obj),
        rotation = normalize_angle(math.rad(base_obj.getRotation()['y']))
    }
end

function get_transform(position, corners, rotation)
    return {
        position = position,
        corners = corners,
        rotation = rotation
    }
end

function transform_to_rotation_vector(transform)
    -- The normalization of a normalized is the original
    return {
        x = 0,
        y = math.deg(normalize_angle(transform['rotation'])),
        z = 0
    }
end

function get_closest_transform(pos, transforms)
    local min_distance = nil
    local min_transform = nil

    for base_name, transform in pairs(transforms) do
        local distance = distance_points_flat_sq(transform['corners']['topleft'], pos)
        if min_distance == nil or min_distance > distance then
            min_distance = distance
            min_transform = transform
        end
    end
    return min_transform
end

function get_strokes_future_position(base_obj, transform)
    local stroke_points = {}
    table.insert(stroke_points, transform['corners']['topright'])
    table.insert(stroke_points, transform['corners']['topleft'])
    table.insert(stroke_points, transform['corners']['botleft'])
    table.insert(stroke_points, transform['corners']['botright'])
    table.insert(stroke_points, transform['corners']['topright'])

    local color = g_gizmo_color_player_red
    if is_base_blue_player(base_obj.getName()) then
        color = g_gizmo_color_player_blue
    end

    return
    {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_zoc(base_obj, transform)
    local stroke_points = {}
    local p = transform['corners']['topright']
    table.insert(stroke_points, p)
    table.insert(stroke_points, {
        x = p['x'],
        y = p['y'],
        z = p['z'] + g_base_width_inches
    })
    table.insert(stroke_points, {
        x = p['x'] - g_base_width_inches,
        y = p['y'],
        z = p['z'] + g_base_width_inches
    })
    table.insert(stroke_points, {
        x = p['x'] - g_base_width_inches,
        y = p['y'],
        z = p['z']
    })
    table.insert(stroke_points, p)

    local rotation = transform['rotation']
    for _, paux in ipairs(stroke_points) do
        local paux_rotated = rotate_point(paux, p, rotation)
        paux['x'] = paux_rotated['x']
        -- We can ignore the y because we assume XZ plane
        paux['z'] = paux_rotated['z']
    end

    local color = g_gizmo_zoc_color_player_red
    if is_base_blue_player(base_obj.getName()) then
        color = g_gizmo_zoc_color_player_blue
    end

    return
    {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

-- A bow fires 2" forward from each corner of the bases, but only up to a base
-- width, not the full 2"
--
--           p4       p3
--         **----------**
--     ****  |        |  ****
-- p5 **     |        |     **  p2
--    |      |        |       |
--    -------------------------
--   p6               p       p1
--
-- The exact coordinates work like this
--    p_x, p_z+2"
--       |*****
--       |     *****
--       |         **** p_x + 40mm * cos(x), p_y + 40mm*sin(x) + (complex_calc)
--       |             ***
--       |               ***
--       |                  *
--       |                  **
--       |                   * p_x+40mm, (complex_calc)
--       |                   |
--       |                   | side
--       ---------------------
--     p_x, p_Z           p_x+40mm, p_z
--
-- This is mirrored in two sides, then everything is adjusted for rotation
function get_strokes_fire_arc(base_obj, transform, shooting_range, max_width)
    local stroke_points = {}
    local p = transform['corners']['topright']

    local max_angle_arc = math.acos(g_base_width_inches / shooting_range)
    local side_height = math.sin(max_angle_arc) * shooting_range

    table.insert(stroke_points, p)
    table.insert(stroke_points, {
        x = p['x'] + max_width,
        y = p['y'],
        z = p['z']
    })
    table.insert(stroke_points, {
        x = p['x'] + max_width,
        y = p['y'],
        z = p['z'] + side_height
    })
    local radius_right = {
        x = p['x'],
        y = p['y'],
        z = p['z']
    }
    local right_arc = get_coordinates_arc(
        radius_right,
        shooting_range,
        g_precision_circle / 4,
        math.deg(max_angle_arc),
        90)
    array_concat(stroke_points, right_arc)
    table.insert(stroke_points, {
        x = p['x'],
        y = p['y'],
        z = p['z'] + shooting_range
    })
    table.insert(stroke_points, {
        x = p['x'] - max_width,
        y = p['y'],
        z = p['z'] + shooting_range
    })
    local radius_left = {
        x = p['x'] - max_width,
        y = p['y'],
        z = p['z']
    }
    local left_arc = get_coordinates_arc(
        radius_left,
        shooting_range,
        g_precision_circle / 4,
        90,
        90 + (90 - math.deg(max_angle_arc)))
    array_concat(stroke_points, left_arc)
    table.insert(stroke_points, {
        x = p['x'] - max_width * 2,
        y = p['y'],
        z = p['z'] + side_height
    })
    table.insert(stroke_points, {
        x = p['x'] - max_width * 2,
        y = p['y'],
        z = p['z']
    })
    table.insert(stroke_points, p)

    local rotation = transform['rotation']
    for _, paux in ipairs(stroke_points) do
        local paux_rotated = rotate_point(paux, p, rotation)
        paux['x'] = paux_rotated['x']
        -- We can ignore the y because we assume XZ plane
        paux['z'] = paux_rotated['z']
    end

    local color = g_gizmo_fire_color_player_red
    if is_base_blue_player(base_obj.getName()) then
        color = g_gizmo_fire_color_player_blue
    end

    return
    {
        points    = stroke_points,
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function get_strokes_bow(base_obj, transform)
    return get_strokes_fire_arc(base_obj, transform, g_bow_range, g_base_width_inches)
end

function get_strokes_art(base_obj, transform)
    return get_strokes_fire_arc(base_obj, transform, g_art_range, g_base_width_inches)
end

function draw_gizmo_future_movements(new_selected_items)
    if #new_selected_items == 0 then
        Global.setVectorLines({})
        return
    end

    local strokes = {}
    local magnitude = g_paces_movement / 100
    for _, obj in ipairs(new_selected_items) do
        if g_bases[obj.getName()] ~= nil then
            local transform = calculate_future_position(obj, magnitude)

            table.insert(strokes, get_strokes_future_position(obj, transform))

            if str_has_substr(obj.getName(), 'Bw')
               or str_has_substr(obj.getName(), 'Cb') then
                table.insert(strokes, get_strokes_bow(obj, transform))
            elseif str_has_substr(obj.getName(), 'Art') then
                table.insert(strokes, get_strokes_art(obj, transform))
            end

            if g_zoc_enabled then
                table.insert(strokes, get_strokes_zoc(obj, transform))
            end
        end

    end
    Global.setVectorLines(strokes)
end

function get_strokes_deployment(pos, color)
    local half_width = g_width_table_in / 2
    local half_depth = g_depth_table_in / 2

    local xpos = 1
    local zpos = 1

    if pos == 'topright' then
        xpos = 1
        zpos = 1
    elseif pos == 'topleft' then
        xpos = -1
        zpos = 1
    elseif pos == 'botright' then
        xpos = 1
        zpos = -1
    elseif pos == 'botleft' then
        xpos = -1
        zpos = -1
    end

    local pos1 = {
        x = xpos * half_width,
        y = g_table_thickness,
        z = zpos * half_depth - zpos * g_deploy_home_in
    }
    local pos2 = {
        x = xpos * half_width - xpos * g_deploy_side_in,
        y = g_table_thickness,
        z = zpos * half_depth - zpos * g_deploy_home_in
    }
    local pos3 = {
        x = xpos * half_width - xpos * g_deploy_side_in,
        y = g_table_thickness,
        z = zpos * half_depth
    }
    return {
        points    = {pos1, pos2, pos3},
        color     = color,
        thickness = g_line_thickness,
        rotation  = {0,0,0}
    }
end

function draw_deployment_lines()
    local strokes = {}
    table.insert(strokes, get_strokes_deployment('topright', g_gizmo_color_player_blue))
    table.insert(strokes, get_strokes_deployment('topleft', g_gizmo_color_player_blue))
    table.insert(strokes, get_strokes_deployment('botright', g_gizmo_color_player_red))
    table.insert(strokes, get_strokes_deployment('botleft', g_gizmo_color_player_red))
    g_current_table.setVectorLines(strokes)
end

function remove_deployment_lines()
    g_current_table.setVectorLines({})
end

function on_selection_changed(player_color, new_selected_items)
    draw_gizmo_future_movements(new_selected_items)
end

function has_changed_selection_for_player(player_color, selected_objs)
    return not array_equals(
                selected_objs,
                g_selected_objects[player_color],
                function(obj1, obj2)
                    return obj1.guid == obj2.guid
                end)
end

-- TODO: Move to a spawned coroutine that does something everyhalf a second
-- or similar to improve perf, and only starts on pickup
g_selected_objects = {}
function onUpdate()
    if g_picked_base_obj then
        local new_corners = compute_corners_base(g_picked_base_obj)
        local distance = max_distance_between_bases(new_corners, g_picked_base_initial_transform['corners']) * 100

        UI.setAttribute('panel_current_movement', 'active', true)
        UI.setValue('text_current_movement_paces',
            'Current movement: ' .. string.format('%.1f', distance) .. ' paces' )
    else
        UI.setAttribute('panel_current_movement', 'active', false)
    end

    local players = Player.getPlayers()
    for _, player in ipairs(players) do
        local selected_objs = player.getSelectedObjects()
        if has_changed_selection_for_player(player.color, selected_objs) then
            on_selection_changed(player.color, selected_objs)
            g_selected_objects[player.color] = selected_objs
        end
    end
end
