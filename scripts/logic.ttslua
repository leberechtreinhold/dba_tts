-- Given a base object, computes the 4 bounds points, returned in a table,
-- each with a vector xyz of world pos coords
--
--   topleft         rotation      topright
--      +-------------^--------------+
--      |             |              |
--      |             * center       |  z axis
--      |                            |
--      +----------------------------+
--    botleft      x axis          botright
function compute_corners_base(base_obj)
    local bounds = base_obj.getBoundsNormalized()
    local rotation =  normalize_angle(from_degrees_to_rad(base_obj.getRotation())['y'])
    -- print_debug(base_obj.getName() .. ' rotation is ' .. rotation)
    local size = bounds['size']
    local pos = base_obj.getPosition()
    -- print_debug(base_obj.getName() .. ' pos is ' .. vec_to_str(vec_in_to_mm(pos)))
    return compute_corners_coords(size, rotation, pos)
end

-- Like compute_corners_base but instead of a base obj all coords are given
function compute_corners_coords(sizeXZ, rotationY, pos)
    local xhalf = sizeXZ['x'] / 2
    local zhalf = sizeXZ['z'] / 2

    return {
        topright = rotate_point({x = xhalf, y = 0, z = zhalf}, pos, rotationY),
        botright = rotate_point({x = xhalf, y = 0, z =-zhalf}, pos, rotationY),
        topleft  = rotate_point({x =-xhalf, y = 0, z = zhalf}, pos, rotationY),
        botleft  = rotate_point({x =-xhalf, y = 0, z =-zhalf}, pos, rotationY)
    }
end

-- Given two base objects, aligns them so they share on side, the closest
-- base2 will align to base1, and it's assumed that base1 is to the left of
-- base2 (that is, the X component is smaller)
-- TODO this only aligns with the right side atm
function align_two_bases(player, base1, base2)
    if (distance_points_flat_sq(base1.getPosition(), base2.getPosition()) > 9) then
        print_error(player.steam_name .. ' is trying to align but the bases are too far apart, more than 3inch between centers!')
        return
    end

    print_info(player.steam_name .. ' is aligning ' .. base1.getName() .. ' with ' .. base2.getName())
    base2.setRotation(base1.getRotation())

    local corners1 = compute_corners_base(base1)
    print_debug('CORNERS ' .. base1.getName() .. corners_to_str(corners_in_to_mm(corners1)))
    local corners2 = compute_corners_base(base2)
    print_debug('CORNERS ' .. base2.getName() .. corners_to_str(corners_in_to_mm(corners2)))
    local translation = vec_sub(corners1['topright'], corners2['topleft'])
    print_debug('Translation is ' .. vec_to_str(vec_in_to_mm(translation)))
    base2.setPosition(vec_add(base2.getPosition(), translation))
    print_info(base2.getName() .. ' has aligned to ' .. base1.getName())
    print_debug('CORNERS AFTER' .. base2.getName() .. corners_to_str(corners_in_to_mm(corners2)))
end

-- Given a list of objects in a table, returns another table with ONLY
-- those who start with 'base', ignoring the keys
function filter_bases(list)
    local filtered = {}
    for _,obj in ipairs(list) do
        if str_starts_with(obj.getName(), 'base') then
            table.insert(filtered, obj)
        end
    end
    return filtered
end

-- Moves one or more DBA bases g_paces_movements paces forward
-- ASSUMES all bases are in a flat board!!!!
-- Returns how much it moved (it cna move less in a collision)
function move_base(obj, how_many_paces)
    local current_world_pos = obj.getPosition()
    local current_rotation = from_degrees_to_rad(obj.getRotation())
    local displacement_vector = rad_to_vector(current_rotation['y'])
    local magnitude = how_many_paces / 100
    local destination = vec_add(current_world_pos, vec_mul_escalar(displacement_vector, magnitude))
    -- print_debug(player.steam_name .. 'Moving ' .. obj.getName() ..
    -- ' from ' .. vec_to_str(current_world_pos) ..
    -- ' with rotation ' .. vec_to_str(current_rotation) ..
    -- ' to ' .. vec_to_str(destination))
    obj.setPosition(destination)
    -- TODO: COLISION

    return how_many_paces
end

function get_spawn_model(pos, rotation_correction, height_correction, model_scale, model_mesh, model_diffuse, collider_if_exists)
    return {
        spawn = {
            type = 'Custom_Model',
            position = { x = pos['x'], y = pos['y'] + height_correction, z = pos['z']},
            rotation = { x = 0, y = rotation_correction, z = 0},
            scale = { x = model_scale, y = model_scale, z = model_scale},
            sound = false,
            snap_to_grid = false
        },
        custom_obj_attrs = {
            mesh = model_mesh,
            diffuse = model_diffuse,
            material = 1,
            collider = collider_if_exists
        }
    }
end

function spawn_model(troop_name, pos, added_y_axis_rotation, collider, is_player_red)
    -- Better pray that the input name actually exists! lol
    local model_data = _G[troop_name]

    local texture = model_data['player_blue_tex']
    if is_player_red then
        texture = model_data['player_red_tex']
    end

    local meshes = model_data['mesh']
    local mesh_index = math.random(1, #model_data['mesh'])
    local selected_mesh = meshes[mesh_index]
    local spawn_data = get_spawn_model(pos,
        model_data['rotation'],
        model_data['height_correction'],
        model_data['scale'],
        selected_mesh,
        texture,
        collider)
    spawn_data['spawn']['rotation']['y'] = spawn_data['spawn']['rotation']['y'] + added_y_axis_rotation
    local obj = spawnObject(spawn_data['spawn'])
    obj.setCustomObject(spawn_data['custom_obj_attrs'])

    return obj
end

function get_depth_base(base_name)
    local base_data = _G[base_name]
    return from_mm_to_in(base_data['depth'])
end

g_base_index = 1

function spawn_base(base, pos, is_red_player)
    local base_obj = spawn_model(base['base'], pos, 0, nil, is_red_player)
    base_obj.setName('base ' .. base['name'] .. ' #' .. g_base_index)
    g_base_index = g_base_index + 1

    local n = base['n_models']
    if n == 0 then
        return
    end

    local depth = get_depth_base(base['base'])
    local half_depth = depth / 2
    local half_width = base_width_inches / 2

    local rows = 1
    local columns = n
    if n > 4 then
        rows = math.floor(math.sqrt(n))
        columns = math.ceil(n/rows)

    end
    local column_width = base_width_inches / (columns + 1)
    local row_depth = depth / (rows + 1)

    for i=1,n do
        local column = (i - 1) % columns + 1
        local row = math.floor((i - 1) / columns) + 1
        local relative_pos = {
            x = pos['x'] + column * column_width - half_width,
            y = pos['y'] + base_height_inches / 2 + base_obj.getPosition()['y'],
            z = pos['z'] + row * row_depth - half_depth
        }
        local soldier_obj = spawn_model(base['model_data'], relative_pos, math.random(-20, 20), minimal_collider, is_red_player)
        base_obj.addAttachment(soldier_obj)
    end
end

-- Given an army object data, spawns it on the center of the table.
-- Hope nothing is in there and that all data is correct because this doesn't
-- validate
function spawn_army(army, is_red_player)
    local i = 0
    math.randomseed(os.time())
    local n_bases = tlen(army)
    local width_army = n_bases * base_width_inches
    for base_id, base_data in pairs(army) do
        local location = { x = 0 + i * base_width_inches - width_army / 2, y = 0, z = 0 }
        print_debug('Spawning ' .. base_id)
        spawn_base(base_data, location, is_red_player)
        i = i + 1
    end
end

function update_authors_text(army)
    local authorship_models = 'The authors of the models are:\n\n'
    local authors_set = {}
    for _, base in pairs(army) do
        local model = base['model_data']
        local model_data = _G[model]
        local author = model_data['author']

        if authors_set[author] == nil then
            authorship_models = authorship_models .. ' - ' .. author .. '\n\n'
            authors_set[author] = 1
        end
    end
    UI.setValue('text_authors', authorship_models)
end

function update_book_menu(book_selected)
    local options = {}
    for book_name, book_armies in pairs(armies) do
        table.insert(options, dataname_to_friendlyname(book_name))
    end
    set_options_dropdown_by_id('dropdown_book', options, book_selected)
end

function update_player_color_menu(is_player_red)
    local selected = 2
    if is_player_red then
        selected = 1
    end
    set_options_dropdown_by_id('dropdown_color', { 'Red', 'Blue' },  selected)
end

function update_armies_menu(book, army_selected)
    local options = {}
    for army_name,_ in pairs(book) do
        table.insert(options, dataname_to_friendlyname(army_name))
    end
    set_options_dropdown_by_id('dropdown_army', options, army_selected)
end


function max_distance_between_bases(base1_corners, base2_corners)
    return compute_max_array({
        distance_points_flat(base1_corners['topright'], base2_corners['topright']),
        distance_points_flat(base1_corners['topleft'], base2_corners['topleft']),
        distance_points_flat(base1_corners['botright'], base2_corners['botright']),
        distance_points_flat(base1_corners['botleft'], base2_corners['botleft'])
    })
end

g_picked_base_obj = nil
g_picked_base_initial_corners = nil

function onObjectPickUp(player_color,  picked_up_object)
    if not str_has_substr(picked_up_object.getName(), 'base') then
        return
    end

    local objs = filter_bases(Player[player_color].getSelectedObjects())
    local n_objs = tlen(objs)
    if n_objs > 1 then
        -- Ignoring this, we don't want to print the circle for more than one unit
        return
    end

    g_picked_base_obj = picked_up_object
    g_picked_base_initial_corners = compute_corners_base(picked_up_object)
    local pos = picked_up_object.getPosition()
    local radius = g_paces_movement / 100
    Global.setVectorLines( {
        {
            points    = get_coordinates_circle(pos, radius, 32),
            color     = { 0.2, 0.2, 0.9 },
            thickness = 0.1,
            rotation  = {0,0,0}
        }
    })
end

function onObjectDrop(player_color,  picked_up_object)
    if not str_has_substr(picked_up_object.getName(), 'base') then
        return
    end

    local objs = filter_bases(Player[player_color].getSelectedObjects())
    local n_objs = tlen(objs)
    if n_objs > 1 then
        draw_gizmo_future_movements(objs)
        return
    end

    local new_corners = compute_corners_base(picked_up_object)
    print_info('Movement for ' .. picked_up_object.getName() .. ' is: ' .. max_distance_between_bases(new_corners, g_picked_base_initial_corners))

    g_picked_base_obj = nil
    g_picked_base_initial_corners = nil
    Global.setVectorLines({})
    
    -- If its dropped it may have moved, therefore update the gizmo, in case
    -- its selected
    draw_gizmo_future_movements(objs)
end

function get_strokes_future_position(base_obj, movement)
    local rotation = from_degrees_to_rad(base_obj.getRotation())['y']
    local displacement_vector = rad_to_vector(rotation)
    local destination = vec_add(base_obj.getPosition(), vec_mul_escalar(displacement_vector, movement))
    local size = base_obj.getBoundsNormalized()['size']
    local corners = compute_corners_coords(size, normalize_angle(rotation), destination)

    local stroke_points = {}
    table.insert(stroke_points, corners['topright'])
    table.insert(stroke_points, corners['topleft'])
    table.insert(stroke_points, corners['botleft'])
    table.insert(stroke_points, corners['botright'])
    table.insert(stroke_points, corners['topright'])

    return
    {
        points    = stroke_points,
        color     = { 0.2, 0.2, 0.9 },
        thickness = 0.1,
        rotation  = {0,0,0}
    }
end

function draw_gizmo_future_movements(new_selected_items)
    if #new_selected_items == 0 then
        Global.setVectorLines({})
        return
    end

    local strokes = {}
    local magnitude = g_paces_movement / 100
    for _, obj in ipairs(new_selected_items) do
        if str_starts_with(obj.getName(), 'base') then
            table.insert(strokes, get_strokes_future_position(obj, magnitude))
        end
    end
    Global.setVectorLines(strokes)
end

function on_selection_changed(player_color, new_selected_items)
    draw_gizmo_future_movements(new_selected_items)
end

function has_changed_selection_for_player(player_color, selected_objs)
    return not array_equals(
                selected_objs,
                g_selected_objects[player_color],
                function(obj1, obj2)
                    return obj1.guid == obj2.guid
                end)
end

-- TODO: Move to a spawned coroutine that does something everyhalf a second
-- or similar to improve perf, and only starts on pickup

g_selected_objects = {}
function onUpdate()
    if g_picked_base_obj then
        local new_corners = compute_corners_base(g_picked_base_obj)
        local distance = max_distance_between_bases(new_corners, g_picked_base_initial_corners) * 100

        UI.setAttribute('panel_current_movement', 'active', true)
        UI.setValue('text_current_movement_paces',
            'Current movement: ' .. string.format('%.1f', distance) .. ' paces' )
    else
        UI.setAttribute('panel_current_movement', 'active', false)
    end

    local players = Player.getPlayers()
    for _, player in ipairs(players) do
        local selected_objs = player.getSelectedObjects()
        if has_changed_selection_for_player(player.color, selected_objs) then
            on_selection_changed(player.color, selected_objs)
            g_selected_objects[player.color] = selected_objs
        end
    end
end
