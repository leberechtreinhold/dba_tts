-- Given a base object, computes the 4 bounds points, returned in a table,
-- each with a vector xyz of world pos coords
--
--   topleft         rotation      topright
--      +-------------^--------------+
--      |             |              |
--      |             * center       |  z axis
--      |                            |
--      +----------------------------+
--    botleft      x axis          botright
function compute_corners_base(base_obj)
    local rotation = normalize_angle(from_degrees_to_rad(base_obj.getRotation())['y'])
    -- print_debug(base_obj.getName() .. ' rotation is ' .. rotation)
    local size = get_size(base_obj.getName())
    local pos = base_obj.getPosition()
    -- print_debug(base_obj.getName() .. ' pos is ' .. vec_to_str(vec_in_to_mm(pos)))
    return compute_corners_coords(size, rotation, pos)
end

-- Like compute_corners_base but instead of a base obj all coords are given
function compute_corners_coords(sizeXZ, rotationY, pos)
    local xhalf = sizeXZ['x'] / 2
    local zhalf = sizeXZ['z'] / 2

    return {
        topright = rotate_point_relative({x = xhalf, y = 0, z = zhalf}, pos, rotationY),
        botright = rotate_point_relative({x = xhalf, y = 0, z =-zhalf}, pos, rotationY),
        topleft  = rotate_point_relative({x =-xhalf, y = 0, z = zhalf}, pos, rotationY),
        botleft  = rotate_point_relative({x =-xhalf, y = 0, z =-zhalf}, pos, rotationY)
    }
end

-- Aligns base2 to a base1, where base1 is an object that will be (but may not
-- be there until next frame) with center position, corners and rotation.
-- Base2 is to the right of Base1 in the x axis
-- Returns a transform table with the new pos, corners and rot
function align_two_bases(base2, position, corners, rotation)
    base2.setRotation(rotation)
    local corners2 = compute_corners_base(base2)

    local angle = normalize_angle(math.rad(rotation['y']))
    local relative_angle = relative_angle_from_point(position, base2.getPosition(), angle)

    local translation = nil
    -- Note that since we know that base1 is to the left of base2, the angle
    -- is 0-90 or 270-360
    if relative_angle > g_alignment_angle_side
       and relative_angle < math.pi then
        -- Angle the back of base2 with the front of base1
        translation = vec_sub(corners['topright'], corners2['botright'])
    elseif relative_angle <= g_alignment_angle_side
           or relative_angle >= (2*math.pi - g_alignment_angle_side) then
        -- Angle the left side of base2 with the right of base1
        translation = vec_sub(corners['topright'], corners2['topleft'])
    else
        -- Angle the front of base2 with the back of base1
        translation = vec_sub(corners['botleft'], corners2['topleft'])
    end

    local new_pos = vec_add(base2.getPosition(), translation)
    base2.setPosition(new_pos)

    return {
        position = new_pos,
        corners = compute_corners_coords(get_size(base2.getName()),angle, new_pos),
        rotation = rotation
    }
end

-- Given a list of objects in a table, returns another table with ONLY
-- those who start with 'base', ignoring the keys
function filter_bases(list)
    local filtered = {}
    for _,obj in ipairs(list) do
        local name = obj.getName()
        if g_bases[name] ~= nil or str_starts_with(obj.getName(), 'base') then
            table.insert(filtered, obj)
        end
    end
    return filtered
end

-- Moves one or more DBA bases g_paces_movements paces forward
-- ASSUMES all bases are in a flat board!!!!
-- Returns how much it moved (it cna move less in a collision)
function move_base(obj, how_many_paces)
    local current_world_pos = obj.getPosition()
    local current_rotation = from_degrees_to_rad(obj.getRotation())
    local displacement_vector = rad_to_vector(current_rotation['y'])
    local magnitude = how_many_paces / 100
    local destination = vec_add(current_world_pos, vec_mul_escalar(displacement_vector, magnitude))
    -- print_debug(player.steam_name .. 'Moving ' .. obj.getName() ..
    -- ' from ' .. vec_to_str(current_world_pos) ..
    -- ' with rotation ' .. vec_to_str(current_rotation) ..
    -- ' to ' .. vec_to_str(destination))
    obj.setPosition(destination)
    -- TODO: COLISION
    return how_many_paces
end

-- Moves ONE single DBA base by it's depth
function push_back(obj)
    local current_world_pos = obj.getPosition()
    local angle = from_degrees_to_rad(obj.getRotation())['y']
    angle = angle + math.pi
    if angle > 2*math.pi then
        angle = angle - 2*math.pi
    end
    local displacement_vector = rad_to_vector(angle)

    local magnitude = get_size(obj.getName())['z']
    local destination = vec_add(current_world_pos, vec_mul_escalar(displacement_vector, magnitude))
    obj.setPosition(destination)
    -- TODO: COLISION
end

-- Like push back but in the other direction
function push_forward(obj)
    local current_world_pos = obj.getPosition()
    local angle = from_degrees_to_rad(obj.getRotation())['y']
    local displacement_vector = rad_to_vector(angle)

    local magnitude = get_size(obj.getName())['z']
    local destination = vec_add(current_world_pos, vec_mul_escalar(displacement_vector, magnitude))
    obj.setPosition(destination)
    -- TODO: COLISION
end

-- Pushes back a whole column, that may not be exactly aligned
function push_back_column(objs)
    -- We use many comparisons for the column so we precalculate all the
    -- transforms
    local transforms = {}
    for _, obj in ipairs(objs) do
        transforms[obj] = calculate_transform(obj)
    end

    local front_of = {}
    local behind_of = {}
    local not_connected = {}
    for _, objA in ipairs(objs) do
        local in_front = nil
        local in_back = nil

        for _, objB in ipairs(objs) do
            local skip = false
            if not_connected[objA] ~= nil and not_connected[objA][objB] == true then
                skip = true
            end

            if objA == objB  then
                skip = true
            end

            if not skip then
                if front_of[objA] == objB
                   or is_behind(transforms[objA], transforms[objB]) then
                    in_front = objB
                elseif behind_of[objA] == objB
                       or is_behind(transforms[objB], transforms[objA]) then
                    in_back = objB
                else
                    if not_connected[objA] == nil then
                        not_connected[objA] = {}
                    end
                    not_connected[objA][objB] = true
                end
            end
        end

        if in_front == nil and in_back == nil then
            print_error('Trying to pushback ' .. objA.getName() .. ' which is not in column')
            return
        end

        if in_front ~= nil then
            front_of[objA] = in_front
            behind_of[in_front] = objA
        end
        if in_back ~= nil then
            front_of[in_back] = objA
            behind_of[objA] = in_back
        end
    end

    local front_element = nil
    for _, obj in ipairs(objs) do
        if front_of[obj] == nil then
            front_element = obj
            break
        end
    end

    if front_element == nil then
        print_error('Trying to push back but there\'s no front element')
    end

    local base_depth = get_size(front_element.getName())['z']
    local distance = base_depth
    if distance > g_base_width_inches then
        distance = g_base_width_inches
    end

    local angle = from_degrees_to_rad(front_element.getRotation())['y']
    angle = angle + math.pi
    if angle > 2*math.pi then
        angle = angle - 2*math.pi
    end

    -- Move the front_element fist, then align the others to its back
    local displacement_vector = rad_to_vector(angle)
    local destination = vec_add(front_element.getPosition(), vec_mul_escalar(displacement_vector, distance))
    front_element.setPosition(destination)

    local magnitude = base_depth / 2
    local next_element = behind_of[front_element]
    while next_element ~= nil do
        next_element.setRotation(front_element.getRotation())

        base_depth = get_size(next_element.getName())['z']
        magnitude = magnitude + base_depth / 2
        local next_destination = vec_add(destination, vec_mul_escalar(displacement_vector, magnitude))
        next_element.setPosition(next_destination)

        front_element = next_element
        next_element = behind_of[next_element]

        magnitude = magnitude + base_depth / 2
    end
end

-- Checks if the object A defined by its transform is inmediately behind
-- object B, which is also represented by its transform
function is_behind(transformA, transformB)
    local angleA = transformA['rotation']
    local angleB = transformB['rotation']
    local diff_angle = math.abs(angleB - angleA)

    if diff_angle > g_max_angle_pushback_rad
       and diff_angle < (2*math.pi - g_max_angle_pushback_rad) then
       -- Angle is too different, skip
       return false
    end

    local cornersA = transformA['corners']
    local cornersB = transformB['corners']

    local distance = distance_points_flat_sq(cornersA['topright'], cornersB['botright'])
    if distance < g_max_corner_distance_snap then
        distance = distance_points_flat_sq(cornersA['topleft'], cornersB['botleft'])
        if distance < g_max_corner_distance_snap then
            return true
        end
    end
    return false
end

-- Determines if A is to the left of B
function is_left_side(transformA, transformB)
    local angleA = transformA['rotation']
    local angleB = transformB['rotation']
    local diff_angle = math.abs(angleB - angleA)

    if diff_angle > g_max_angle_pushback_rad
       and diff_angle < (2*math.pi - g_max_angle_pushback_rad) then
       -- Angle is too different, skip
       return false
    end

    local cornersA = transformA['corners']
    local cornersB = transformB['corners']

    local distance = distance_points_flat_sq(cornersA['topright'], cornersB['topleft'])
    if distance < g_max_corner_distance_snap then
        -- Note: We do not check the bottom because bases may be of different
        -- sizes and we already check the angle
        return true
    end
    return false
end

-- Determines if A is to the right of B
function is_right_side(transformA, transformB)
    return is_left_side(transformB, transformA)
end

-- Determines if A is in front of B
function is_infront(transformA, transformB)
    return is_behind(transformB, transformA)
end

-- Determines if A is in front B, looking at B, while B looks at A
function is_opposite_front(transformA, transformB)
    local angleA = transformA['rotation']
    local angleB = transformB['rotation']
    local diff_angle = math.abs(angleB - angleA)
    local angle_180 = math.abs(math.pi - diff_angle)

    if angle_180 >= g_max_angle_pushback_rad then
       -- Angle is too different, skip
       return false
    end

    local cornersA = transformA['corners']
    local cornersB = transformB['corners']

    local distance = distance_points_flat_sq(cornersA['topright'], cornersB['topleft'])
    if distance < g_max_corner_distance_snap then
        distance = distance_points_flat_sq(cornersA['topleft'], cornersB['topright'])
        if distance < g_max_corner_distance_snap then
            return true
        end
    end
    return false
end

-- Determines if A is in the of side of B, "closing its door", which in DBA
-- terms means that the left corner of A is touching the left corner B, and A
-- is looking at B, while B does NOT look at A.
function is_closing_door_to_left(transformA, transformB)
    local angleA = transformA['rotation']
    local angleB = transformB['rotation']
    local diff_angle = angleB - angleA
    if diff_angle < 0 then
        diff_angle = diff_angle + 2*math.pi
    end
    local angle_90 = math.abs(math.pi/2 - diff_angle)
    if angle_90 >= g_max_angle_pushback_rad then
       -- Angle is too different, skip
       return false
    end

    local cornersA = transformA['corners']
    local cornersB = transformB['corners']

    local distance = distance_points_flat_sq(cornersA['topleft'], cornersB['topleft'])
    if distance < g_max_corner_distance_snap then
        return true
    end
    return false
end

function is_closing_door_to_right(transformA, transformB)
    local angleA = transformA['rotation']
    local angleB = transformB['rotation']
    local diff_angle = angleB - angleA
    if diff_angle < 0 then
        diff_angle = diff_angle + 2*math.pi
    end
    local angle_270 = math.abs(3*math.pi/2 - diff_angle)
    if angle_270 >= g_max_angle_pushback_rad then
       -- Angle is too different, skip
       return false
    end

    local cornersA = transformA['corners']
    local cornersB = transformB['corners']

    local distance = distance_points_flat_sq(cornersA['topright'], cornersB['topright'])
    if distance < g_max_corner_distance_snap then
        return true
    end
    return false
end

function get_depth_base(tile_name)
    local base_data = _G[tile_name]
    return from_mm_to_in(base_data['depth'])
end

function get_size(base_name)
    return {
        x = g_base_width_inches,
        y = g_base_height_inches,
        z = get_depth_base(g_bases[base_name]['tile'])
    }
end

function is_base_red_player(base_name)
    return g_bases[base_name]['is_red_player']
end

function is_base_blue_player(base_name)
    return not is_base_red_player(base_name)
end

function max_distance_between_bases(base1_corners, base2_corners)
    return compute_max_array({
        distance_points_flat(base1_corners['topright'], base2_corners['topright']),
        distance_points_flat(base1_corners['topleft'], base2_corners['topleft']),
        distance_points_flat(base1_corners['botright'], base2_corners['botright']),
        distance_points_flat(base1_corners['botleft'], base2_corners['botleft'])
    })
end

g_picked_base_obj = nil
g_picked_base_initial_transform = nil
function onObjectPickUp(player_color,  picked_up_object)
    if g_bases[picked_up_object.getName()] == nil then
        return
    end

    local objs = filter_bases(Player[player_color].getSelectedObjects())
    local n_objs = tlen(objs)
    if n_objs > 1 then
        -- Ignoring this, we don't want to print the circle for more than one unit
        return
    end

    g_picked_base_obj = picked_up_object
    g_picked_base_initial_transform = calculate_transform(picked_up_object)

    draw_pickup_strokes(picked_up_object)
end

function snap_to_base(obj, transformObj, base, transformBase, direction)
    print_info(obj.getName() .. ' is snapping to ' .. base.getName() .. ', ' .. direction)
    local new_rotation = base.getRotation()
    if direction == 'opposite' or direction == 'door_left' or direction == 'door_right' then
        local new_y = 0
        if direction == 'opposite' then
            new_y = new_rotation['y'] + 180
        elseif direction == 'door_left' then
            new_y = new_rotation['y'] + 90
        elseif direction == 'door_right' then
            new_y = new_rotation['y'] - 90
        end
        if new_y >= 360 then
            new_y = new_y - 360
        elseif new_y < 0 then
            new_y = new_y + 360
        end
        new_rotation['y'] = new_y
    end
    obj.setRotation(new_rotation)

    local sizeObj = get_size(obj.getName())
    local sizeBase = get_size(base.getName())

    local relative_pos = {x = 0, y = 0, z = 0 }

    if direction == 'infront' or direction == 'opposite' then
        relative_pos['z'] = sizeObj['z'] / 2 + sizeBase['z'] / 2
    elseif direction == 'behind' then
        relative_pos['z'] = -1*(sizeObj['z'] / 2 + sizeBase['z'] / 2)
    elseif direction == 'right' then
        -- Since bases maybe of different sizes, we need to align the front
        relative_pos['x'] = sizeObj['x'] / 2 + sizeBase['x'] / 2
        relative_pos['z'] = -1*(sizeObj['z'] - sizeBase['z']) / 2
    elseif direction == 'left' then
        relative_pos['x'] = -1*(sizeObj['x'] / 2 + sizeBase['x'] / 2)
        relative_pos['z'] = -1*(sizeObj['z'] - sizeBase['z']) / 2
    elseif direction == 'door_left' then
        relative_pos['x'] = -1*(sizeObj['z'] / 2 + sizeBase['x'] / 2)
        relative_pos['z'] = -1*(sizeObj['x'] / 2) + (sizeBase['z'] / 2)
    elseif direction == 'door_right' then
        relative_pos['x'] = sizeObj['z'] / 2 + sizeBase['x'] / 2
        relative_pos['z'] = -1*(sizeObj['x'] / 2) + (sizeBase['z'] / 2)
    else
        print_error('Tried to snap ' .. obj.getName() .. ' in unknown direction ' .. direction)
        return
    end

    local new_pos = rotate_point_relative(
        relative_pos, transformBase['position'], transformBase['rotation'])
    new_pos['y'] = transformBase['position']['y']

    obj.setPosition(new_pos)
end

function snap_picked_base(obj)
    local initial_corners = g_picked_base_initial_transform['corners']

    local pos = obj.getPosition()
    local bases = get_all_bases()
    for _, base in ipairs(bases) do
        local pos_base = base.getPosition()

        -- Discard fast bases that are too far
        local distance = distance_points_flat_sq(pos, pos_base)
        if distance < g_max_distance_alignment and distance ~= 0 then
            local transformObj = calculate_transform(obj)
            local transformBase = calculate_transform(base)

            -- Calculate relative position
            if is_infront(transformObj, transformBase) then
                snap_to_base(obj, transformObj, base, transformBase, 'infront')
                local new_corners = compute_corners_base(obj)
                return max_distance_between_bases(new_corners, initial_corners)

            elseif is_behind(transformObj, transformBase) then
                snap_to_base(obj, transformObj, base, transformBase, 'behind')
                local new_corners = compute_corners_base(obj)
                return max_distance_between_bases(new_corners, initial_corners)

            elseif is_left_side(transformObj, transformBase) then
                snap_to_base(obj, transformObj, base, transformBase, 'left')
                local new_corners = compute_corners_base(obj)
                return max_distance_between_bases(new_corners, initial_corners)

            elseif is_right_side(transformObj, transformBase) then
                snap_to_base(obj, transformObj, base, transformBase, 'right')
                local new_corners = compute_corners_base(obj)
                return max_distance_between_bases(new_corners, initial_corners)

            elseif is_opposite_front(transformObj, transformBase) then
                snap_to_base(obj, transformObj, base, transformBase, 'opposite')
                local new_corners = compute_corners_base(obj)
                return max_distance_between_bases(new_corners, initial_corners)

            elseif is_closing_door_to_left(transformObj, transformBase) then
                snap_to_base(obj, transformObj, base, transformBase, 'door_left')
                local new_corners = compute_corners_base(obj)
                return max_distance_between_bases(new_corners, initial_corners)

            elseif is_closing_door_to_right(transformObj, transformBase) then
                snap_to_base(obj, transformObj, base, transformBase, 'door_right')
                local new_corners = compute_corners_base(obj)
                return max_distance_between_bases(new_corners, initial_corners)
            end
        end
    end

    -- If there's nothing else to snap, maybe I can snap to my initial
    -- position if I moved too little
    local new_corners = compute_corners_base(obj)
    local distance = max_distance_between_bases(new_corners, initial_corners)
    if distance < g_max_inches_snap_reset then
        -- Snap back!
        obj.setPosition(g_picked_base_initial_transform['position'])
        obj.setRotation(transform_to_rotation_vector(g_picked_base_initial_transform))
        return 0
    else
        -- No snapping, return the distance between positions
        return distance
    end
end

function get_all_bases()
    return filter_bases(getAllObjects())
end

function onObjectDrop(player_color,  picked_up_object)
    if g_bases[picked_up_object.getName()] == nil then
        return
    end

    local objs = filter_bases(Player[player_color].getSelectedObjects())
    local n_objs = tlen(objs)
    if n_objs > 1 then
        draw_gizmo_future_movements(objs)
        return
    end

    local distance = 0

    if g_snap_mode_enabled then
        distance = snap_picked_base(picked_up_object)
    else
        local new_corners = compute_corners_base(picked_up_object)
        distance = max_distance_between_bases(new_corners, g_picked_base_initial_transform['corners'])
    end

    print_info(string.format('Movement for %q is %.1f paces',
        picked_up_object.getName(), distance * 100))

    g_picked_base_obj = nil
    g_picked_base_initial_transform = nil
    Global.setVectorLines({})

    -- If its dropped it may have moved, therefore update the gizmo, in case
    -- its selected
    draw_gizmo_future_movements(objs)
end

function calculate_future_position(base_obj, movement)
    local rotation = from_degrees_to_rad(base_obj.getRotation())['y']
    local displacement_vector = rad_to_vector(rotation)
    local destination = vec_add(base_obj.getPosition(), vec_mul_escalar(displacement_vector, movement))
    local size = get_size(base_obj.getName())
    local normalized_rotation = normalize_angle(rotation)
    local corners = compute_corners_coords(size, normalized_rotation, destination)

    return get_transform(
        destination,
        corners,
        normalized_rotation
    )
end

function calculate_transform(base_obj)
    return {
        position = base_obj.getPosition(),
        corners = compute_corners_base(base_obj),
        rotation = normalize_angle(math.rad(base_obj.getRotation()['y']))
    }
end

function transform_to_str(transform)
    return 'Postion: ' .. vec_to_str(transform['position'])
        .. ' Rotation: ' .. math.deg(transform['rotation'])
end

function get_transform(position, corners, rotation)
    return {
        position = position,
        corners = corners,
        rotation = rotation
    }
end

function transform_to_rotation_vector(transform)
    -- The normalization of a normalized is the original
    return {
        x = 0,
        y = math.deg(normalize_angle(transform['rotation'])),
        z = 0
    }
end

function get_closest_transform(pos, transforms)
    local min_distance = nil
    local min_transform = nil

    for base_name, transform in pairs(transforms) do
        local distance = distance_points_flat_sq(transform['corners']['topleft'], pos)
        if min_distance == nil or min_distance > distance then
            min_distance = distance
            min_transform = transform
        end
    end
    return min_transform
end

function on_selection_changed(player_color, new_selected_items)
    draw_gizmo_future_movements(new_selected_items)
end

function has_changed_selection_for_player(player_color, selected_objs)
    return not array_equals(
                selected_objs,
                g_selected_objects[player_color],
                function(obj1, obj2)
                    return obj1.guid == obj2.guid
                end)
end

-- TODO: Move to a spawned coroutine that does something everyhalf a second
-- or similar to improve perf, and only starts on pickup
g_selected_objects = {}
function onUpdate()
    if g_picked_base_obj then
        local new_corners = compute_corners_base(g_picked_base_obj)
        local distance = max_distance_between_bases(new_corners, g_picked_base_initial_transform['corners']) * 100

        UI.setAttribute('panel_current_movement', 'active', true)
        UI.setValue('text_current_movement_paces',
            'Current movement: ' .. string.format('%.1f', distance) .. ' paces' )
    else
        UI.setAttribute('panel_current_movement', 'active', false)
    end

    local players = Player.getPlayers()
    for _, player in ipairs(players) do
        local selected_objs = player.getSelectedObjects()
        if has_changed_selection_for_player(player.color, selected_objs) then
            on_selection_changed(player.color, selected_objs)
            g_selected_objects[player.color] = selected_objs
        end
    end
end
