-- Given two tables with x,y,z numerical components, computes the dot product of them
function vec_dot_product(vec1, vec2)
    return { x = vec1['x'] * vec2['x'], y = vec1['y'] * vec2['y'], z = vec1['z'] * vec2['z'] }
end

-- Given two tables with x,y,z numerical components, computes the sum of both
function vec_add(vec1, vec2)
    return { x = vec1['x'] + vec2['x'], y = vec1['y'] + vec2['y'], z = vec1['z'] + vec2['z'] }
end

-- Given two tables with x,y,z numerical components, computes the vec1-vec2
function vec_sub(vec1, vec2)
    return { x = vec1['x'] - vec2['x'], y = vec1['y'] - vec2['y'], z = vec1['z'] - vec2['z'] }
end

-- Given a table with x,y,z numerical components, and a escalar number, returns a vector with each component multiplied
function vec_mul_escalar(vec, num)
    return { x = vec['x'] * num, y = vec['y'] * num, z = vec['z'] * num }
end

-- Given a table with x,y,z numerical components, and a escalar number, returns a vector with each component divided
function vec_div_escalar(vec, num)
    return { x = vec['x'] / num, y = vec['y'] / num, z = vec['z'] / num }
end

-- Given a table with x,y,z numerical components representing inches, return the same vector with each component being in mm
function vec_in_to_mm(vec)
    return { x = from_in_to_mm(vec['x']), y = from_in_to_mm(vec['y']), z = from_in_to_mm(vec['z']) }
end

-- Given a tables with x,y,z numerical components, returns a [x,y,z] string with two decimals of precision
function vec_to_str(vec)
    return '[' .. string.format('%.2f',vec['x']) .. ', ' .. string.format('%.2f',vec['y']) .. ', ' .. string.format('%.2f',vec['z']) .. ']'
end

-- As insane as it sounds, tables in lua don't have a well-defined way of getting the number of entries
-- If the table is anything but a contiguous array, the # operator is useless. This computes that.
-- Beware that this iterates the whole table and is therefore, perf intensive.
function tlen(table)
    local n = 0
    for _ in pairs(table) do n = n + 1 end
    return n
end

-- Given a tables with x,y,z each with a degree number [0-360], returns a table with x,y,z converted to radians (o, 2pi)
function from_degrees_to_rad(vec)
    return { x = math.rad(vec['x']),  y = math.rad(vec['y']), z = math.rad(vec['z']) }
end

function from_in_to_mm(inches)
    return inches * 25.4
end

-- Given two tables with x,y,z representing world coords, calculates the distance between them in x,z, SQUARED
-- This is because we don't need the square root in most cases
function distance_points_flat_sq(point1, point2)
    return point1['x'] - point2['x'] + point1['z'] - point2['z']
end

-- Given a number of radians (0, 2pi), returns a table with x,y,z components,
-- where y 0 is always 0 and x,z is the rotation value corresponding to those
-- radians, x being updown and z leftright
function rad_to_vector(radians)
    return { x = math.sin(radians), y = 0, z = math.cos(radians) }
end

-- Angles in TTS can be pretty funny: the y axis defines the rotation from +x to
-- -y to -x to +y, which is pretty unintuitive, but I guess they wanted the
-- degrees to be clockwise instead of counterclockwise...
-- This makes them counterclockwise, x goes to -y to -x
function normalize_angle(angle)
    return 2*math.pi - angle
end

-- Given a point with xyz coordinates, where xz form a plane, rotates using
-- an angle theta, respective to a coordinate system with xyz coordinates,
-- on that same plane (leaving y untouched)
function rotate_point(point, center_coordinates, theta)
    theta = normalize_angle(theta)
    return { x = point['x'] * math.cos(theta) - point['z'] * math.sin(theta) + center_coordinates['x'],
             y = point['y'] + center_coordinates['y'],
             z = point['x'] * math.sin(theta) + point['z'] * math.cos(theta) + center_coordinates['z']}
end

-- Given a table with four corners top/bot left/right, each with a xyz
-- vector representing coordinates in inches, returns the same table but
-- each coords is in mm
function corners_in_to_mm(corner)
    return {
        topright = vec_in_to_mm(corner['topright']),
        botright = vec_in_to_mm(corner['botright']),
        topleft  = vec_in_to_mm(corner['topleft']),
        botleft  = vec_in_to_mm(corner['botleft'])
    }
end

-- Given a table with four corners top/bot left/right, each with a xyz
-- vector representing coordinates, returns a str version of it
-- { corner = [coords], corner = [coords], ...}
function corners_to_str(corner)
    return '{' ..
        'topright=' .. vec_to_str(corner['topright']) .. ', ' ..
        'botright=' .. vec_to_str(corner['botright']) .. ', ' ..
        'topleft='  .. vec_to_str(corner['topleft'])  .. ', ' ..
        'botleft='  .. vec_to_str(corner['botleft']) .. '}'
end

-- Rounds a number to the power of ten given
-- For example, round_to_power(123, 1) => 120, round_to_power(123, 2) => 100
function round_to_power(number, power)
    return math.floor(number/(10^power) + 0.5) * 10^power
end


-- Checks if the given str starts with substr
function str_starts_with(str, substr)
    return string.find(str, '^' .. substr) ~= nil
end

function str_has_substr(str, substr)
    return string.find(str, substr) ~= nil
end

-- Helper function for find_ui_element
function find_ui_element_in_element(root_element, id)
    for k, v in pairs(root_element) do
        if k == 'attributes' then
            for kattr, vattr in pairs(v) do
                if kattr == 'id' and vattr == id then
                    return root_element
                end
            end
        end
        if k == 'children' then
            return find_ui_element_list(v, id)
        end
    end
    return nil
end

-- Helper function for find_ui_element
function find_ui_element_list(root_list, id)
    for i,element in ipairs(root_list) do
        local element = find_ui_element_in_element(element, id)
        if element ~= nil then
            return element
        end
    end
    return nil
end

-- Normally you can get the UI elements by using UI functions, but there are
-- things that are not retrieved in that data, like the options tags from the
-- XML in a dropdown. For those, this functions allows to get that info,
-- including all children.
-- This searches the full XML table, so it's perf intensive.
function find_ui_element(id)
    return find_ui_element_list(UI.getXmlTable(), id)
end

-- Given a dropdown element as returned by find_ui_element, returns a list of
-- the options. All options should have a value set.
function get_options_dropdown(dropdown_element)
    local list = {}
    local children = dropdown_element['children']
    if children == nil then
        return list
    end
    for i,option in ipairs(children) do
        list.insert(option['value'])
    end  
end

-- Given a dropdown element as returned by find_ui_element, changes the element
-- to contain the options desired.
-- NOTE This does NOT update the UI and should be used with find_ui_element
-- and setXmlTable()
function set_options_dropdown(dropdown_element, options, idx_selected)
    local children = dropdown_element['children']
    if children ~= nil then
        -- Delete all elements on the table but keep the reference
        local n = #children
        for i=0, n do children[i]=nil end
    end

    for i, option in ipairs(options) do
        local new_options = {
            tag = 'option',
            value = option
        }
        if i == idx_selected then
            new_options['attributes'] = {
                selected = true
            }
        end
        table.insert(children, i, new_options)
    end
end

-- Given an id corresponding to an existing <Dropdown> element on the current
-- XML UI, edits the options to those given.
-- The list of options should be a plain array of strings
-- The index (1 to n) represent which one is currently selected.
-- This is perf intensive, beware. It's also not updated until the next frame.
function set_options_dropdown_by_id(id,  options, idx_selected)
    local xml = UI.getXmlTable()
    local element = find_ui_element_list(xml, id)
    set_options_dropdown(element, options, idx_selected)
    UI.setXmlTable(xml)
end

-- Executes f() on the next frame. This is useful because if you are using
-- methodfs than change the UI using setXmlTable they may enter in conflict
-- since it takes time to update.
-- This is a very terrible way of doing things and should not be used, doesn't
-- support more than one at once. However, you can nest them.
g_func_next_frame = nil
function on_next_frame(f)
    if (g_func_next_frame == nil) then
        g_func_next_frame = f
        startLuaCoroutine(self, 'on_next_frame_coroutine')
    else
        print_error('Trying to add a new coroutine when the next frame has yet to pass')
    end
end

function on_next_frame_coroutine()
    coroutine.yield(0)
    local cur_f = g_func_next_frame
    g_func_next_frame = nil
    cur_f()
    return 1
end